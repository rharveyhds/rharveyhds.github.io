<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Exploit Suite</title>
    <style>
        body {
            font-family: monospace;
            background: #0a0a2a;
            color: #00ff00;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        h1 {
            color: #00ffff;
            border-bottom: 2px solid #00ffff;
            padding-bottom: 10px;
        }
        .warning {
            background: #2a2a00;
            border: 2px solid #ffff00;
            padding: 15px;
            margin: 15px 0;
            color: #ffff00;
        }
        .test-section {
            background: #1a1a3a;
            border: 1px solid #00ff00;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: monospace;
            font-weight: bold;
            border-radius: 3px;
        }
        button:hover {
            background: #00ffff;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .log {
            background: #000;
            border: 1px solid #00ff00;
            padding: 10px;
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.85em;
        }
        h3 {
            color: #00ffff;
            margin-top: 0;
        }
        .status {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 3px;
            margin-left: 10px;
            font-size: 0.85em;
        }
        .status.running {
            background: #666600;
            color: #ffff00;
        }
        .status.passed {
            background: #006600;
            color: #00ff00;
        }
        .status.failed {
            background: #660000;
            color: #ff0000;
        }
        .progress {
            background: #333;
            height: 20px;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            background: #00ff00;
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-size: 0.8em;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Canvas & Graphics Vulnerability Tests</h1>
        
        <div class="warning">
            ⚠️ These tests explore canvas memory limits and graphics-related vulnerabilities.
            Tests are designed to avoid hanging by using incremental limits.
        </div>

        <div class="test-section">
            <h3>Test 1: Canvas Size Limit Discovery <span class="status" id="status1"></span></h3>
            <p>Binary search to find maximum canvas dimensions before failure</p>
            <button onclick="testCanvasSizeLimit()" id="btn1">Run Test</button>
            <div class="log" id="log1"></div>
        </div>

        <div class="test-section">
            <h3>Test 2: Canvas Count Limit Discovery <span class="status" id="status2"></span></h3>
            <p>Find how many canvases can be created before memory exhaustion</p>
            <button onclick="testCanvasCountLimit()" id="btn2">Run Test</button>
            <div class="progress"><div class="progress-bar" id="progress2">0%</div></div>
            <div class="log" id="log2"></div>
        </div>

        <div class="test-section">
            <h3>Test 3: ImageData Race Condition <span class="status" id="status3"></span></h3>
            <p>Tests race conditions in getImageData/putImageData operations</p>
            <button onclick="testImageDataRace()" id="btn3">Run Test</button>
            <div class="log" id="log3"></div>
        </div>

        <div class="test-section">
            <h3>Test 4: Canvas Context Corruption <span class="status" id="status4"></span></h3>
            <p>Attempts to corrupt canvas context state through rapid operations</p>
            <button onclick="testContextCorruption()" id="btn4">Run Test</button>
            <div class="log" id="log4"></div>
        </div>

        <div class="test-section">
            <h3>Test 5: toDataURL/toBlob Memory Leak <span class="status" id="status5"></span></h3>
            <p>Tests for memory leaks in canvas export operations</p>
            <button onclick="testCanvasExport()" id="btn5">Run Test</button>
            <div class="log" id="log5"></div>
        </div>

        <div class="test-section">
            <h3>Test 6: Canvas Pattern/Gradient Overflow <span class="status" id="status6"></span></h3>
            <p>Tests pattern and gradient creation for buffer overflows</p>
            <button onclick="testPatternOverflow()" id="btn6">Run Test</button>
            <div class="log" id="log6"></div>
        </div>

        <div class="test-section">
            <h3>Test 7: Canvas Transform Matrix Bugs <span class="status" id="status7"></span></h3>
            <p>Tests transformation matrix edge cases and precision issues</p>
            <button onclick="testTransformBugs()" id="btn7">Run Test</button>
            <div class="log" id="log7"></div>
        </div>

        <div class="test-section">
            <h3>Test 8: Cross-Canvas Memory Confusion <span class="status" id="status8"></span></h3>
            <p>Tests for memory confusion between multiple canvas contexts</p>
            <button onclick="testCrossCanvasConfusion()" id="btn8">Run Test</button>
            <div class="log" id="log8"></div>
        </div>
    </div>

    <script>
        function log(testNum, message) {
            const logEl = document.getElementById('log' + testNum);
            const timestamp = new Date().toLocaleTimeString();
            logEl.textContent += `[${timestamp}] ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        function setStatus(testNum, status) {
            const statusEl = document.getElementById('status' + testNum);
            statusEl.textContent = status;
            statusEl.className = 'status ' + status.toLowerCase();
        }

        function disableButton(testNum) {
            document.getElementById('btn' + testNum).disabled = true;
        }

        function enableButton(testNum) {
            document.getElementById('btn' + testNum).disabled = false;
        }

        // Test 1: Canvas Size Limit Discovery
        async function testCanvasSizeLimit() {
            setStatus(1, 'RUNNING');
            disableButton(1);
            log(1, 'Starting canvas size limit discovery...');
            
            try {
                let low = 256;
                let high = 16384;
                let maxSize = 0;
                
                log(1, 'Binary searching for maximum canvas dimension...');
                
                while (low <= high) {
                    const mid = Math.floor((low + high) / 2);
                    log(1, `Testing ${mid}x${mid} canvas...`);
                    
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = mid;
                        canvas.height = mid;
                        const ctx = canvas.getContext('2d');
                        
                        if (!ctx) {
                            log(1, `Failed to get context at ${mid}x${mid}`);
                            high = mid - 1;
                            continue;
                        }
                        
                        // Try to actually use it
                        ctx.fillStyle = 'red';
                        ctx.fillRect(0, 0, 10, 10);
                        
                        maxSize = mid;
                        log(1, `✓ ${mid}x${mid} succeeded`);
                        low = mid + 1;
                        
                        // Small delay to prevent hanging
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                    } catch (e) {
                        log(1, `✗ ${mid}x${mid} failed: ${e.message}`);
                        high = mid - 1;
                    }
                }
                
                log(1, `Maximum canvas size found: ${maxSize}x${maxSize}`);
                log(1, `Total pixels: ${maxSize * maxSize} (${(maxSize * maxSize * 4 / 1024 / 1024).toFixed(2)} MB)`);
                setStatus(1, 'PASSED');
                
            } catch (e) {
                log(1, `Exception: ${e.message}`);
                setStatus(1, 'FAILED');
            }
            enableButton(1);
        }

        // Test 2: Canvas Count Limit Discovery
        async function testCanvasCountLimit() {
            setStatus(2, 'RUNNING');
            disableButton(2);
            log(2, 'Finding maximum canvas count...');
            
            try {
                const canvases = [];
                const canvasSize = 1024; // Use moderate size
                let count = 0;
                const maxAttempts = 500; // Prevent infinite loop
                
                log(2, `Creating ${canvasSize}x${canvasSize} canvases...`);
                
                for (let i = 0; i < maxAttempts; i++) {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = canvasSize;
                        canvas.height = canvasSize;
                        const ctx = canvas.getContext('2d');
                        
                        if (!ctx) {
                            log(2, `Failed to get context at canvas #${i}`);
                            break;
                        }
                        
                        // Fill with data to ensure memory allocation
                        ctx.fillStyle = `rgb(${i % 255}, ${(i * 2) % 255}, ${(i * 3) % 255})`;
                        ctx.fillRect(0, 0, canvasSize, canvasSize);
                        
                        canvases.push(canvas);
                        count = i + 1;
                        
                        if (i % 10 === 0) {
                            const progress = Math.min(100, (i / maxAttempts * 100));
                            document.getElementById('progress2').style.width = progress + '%';
                            document.getElementById('progress2').textContent = `${count} canvases`;
                            log(2, `Created ${count} canvases (${(count * canvasSize * canvasSize * 4 / 1024 / 1024).toFixed(2)} MB)...`);
                            
                            // Yield to prevent hanging
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                        
                    } catch (e) {
                        log(2, `Exception at canvas #${i}: ${e.message}`);
                        break;
                    }
                }
                
                log(2, `Maximum canvases created: ${count}`);
                log(2, `Total memory: ${(count * canvasSize * canvasSize * 4 / 1024 / 1024).toFixed(2)} MB`);
                
                // Cleanup
                log(2, 'Cleaning up canvases...');
                canvases.length = 0;
                
                setStatus(2, 'PASSED');
                
            } catch (e) {
                log(2, `Exception: ${e.message}`);
                setStatus(2, 'FAILED');
            }
            enableButton(2);
        }

        // Test 3: ImageData Race Condition
        async function testImageDataRace() {
            setStatus(3, 'RUNNING');
            disableButton(3);
            log(3, 'Testing ImageData race conditions...');
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                log(3, 'Creating initial image data...');
                ctx.fillStyle = 'red';
                ctx.fillRect(0, 0, 512, 512);
                
                log(3, 'Starting rapid getImageData/putImageData cycle...');
                
                for (let i = 0; i < 100; i++) {
                    const imageData1 = ctx.getImageData(0, 0, 512, 512);
                    const imageData2 = ctx.getImageData(0, 0, 512, 512);
                    
                    // Modify while another operation is pending
                    ctx.fillStyle = `rgb(${i % 255}, 0, 0)`;
                    ctx.fillRect(0, 0, 512, 512);
                    
                    // Try to put old data back
                    ctx.putImageData(imageData1, 0, 0);
                    ctx.putImageData(imageData2, 0, 0);
                    
                    if (i % 10 === 0) {
                        log(3, `Iteration ${i}/100...`);
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                log(3, 'Testing overlapping regions...');
                for (let i = 0; i < 50; i++) {
                    const data1 = ctx.getImageData(0, 0, 256, 256);
                    const data2 = ctx.getImageData(128, 128, 256, 256);
                    
                    ctx.putImageData(data1, 128, 128);
                    ctx.putImageData(data2, 0, 0);
                }
                
                log(3, 'Test completed');
                setStatus(3, 'PASSED');
                
            } catch (e) {
                log(3, `Exception: ${e.message}`);
                setStatus(3, 'FAILED');
            }
            enableButton(3);
        }

        // Test 4: Canvas Context Corruption
        async function testContextCorruption() {
            setStatus(4, 'RUNNING');
            disableButton(4);
            log(4, 'Testing context corruption...');
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 600;
                const ctx = canvas.getContext('2d');
                
                log(4, 'Rapidly changing context state...');
                
                for (let i = 0; i < 1000; i++) {
                    ctx.save();
                    ctx.fillStyle = `rgb(${i % 255}, ${(i * 2) % 255}, ${(i * 3) % 255})`;
                    ctx.strokeStyle = `rgb(${(i * 3) % 255}, ${i % 255}, ${(i * 2) % 255})`;
                    ctx.lineWidth = (i % 50) + 1;
                    ctx.globalAlpha = Math.random();
                    ctx.globalCompositeOperation = ['source-over', 'multiply', 'screen', 'overlay'][i % 4];
                    
                    ctx.fillRect(Math.random() * 800, Math.random() * 600, 50, 50);
                    ctx.restore();
                    
                    if (i % 100 === 0) {
                        log(4, `${i}/1000 operations...`);
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                log(4, 'Testing excessive save/restore nesting...');
                for (let i = 0; i < 10000; i++) {
                    ctx.save();
                }
                log(4, 'Saved 10000 states');
                
                for (let i = 0; i < 10000; i++) {
                    ctx.restore();
                }
                log(4, 'Restored 10000 states');
                
                log(4, 'Testing state corruption with invalid values...');
                try {
                    ctx.lineWidth = -1;
                    ctx.lineWidth = Infinity;
                    ctx.lineWidth = NaN;
                    ctx.globalAlpha = -1;
                    ctx.globalAlpha = 2;
                    log(4, 'Invalid values handled');
                } catch (e) {
                    log(4, `Invalid value exception: ${e.message}`);
                }
                
                log(4, 'Test completed');
                setStatus(4, 'PASSED');
                
            } catch (e) {
                log(4, `Exception: ${e.message}`);
                setStatus(4, 'FAILED');
            }
            enableButton(4);
        }

        // Test 5: toDataURL/toBlob Memory Leak
        async function testCanvasExport() {
            setStatus(5, 'RUNNING');
            disableButton(5);
            log(5, 'Testing canvas export operations...');
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 1024;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = 'blue';
                ctx.fillRect(0, 0, 1024, 1024);
                
                log(5, 'Repeatedly calling toDataURL...');
                const dataUrls = [];
                
                for (let i = 0; i < 50; i++) {
                    const dataUrl = canvas.toDataURL('image/png');
                    dataUrls.push(dataUrl);
                    
                    if (i % 10 === 0) {
                        log(5, `Generated ${i + 1} data URLs (${(dataUrl.length / 1024).toFixed(2)} KB each)...`);
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                log(5, `Total memory in data URLs: ${(dataUrls.reduce((sum, url) => sum + url.length, 0) / 1024 / 1024).toFixed(2)} MB`);
                
                if (canvas.toBlob) {
                    log(5, 'Testing toBlob...');
                    const blobs = [];
                    
                    for (let i = 0; i < 20; i++) {
                        await new Promise((resolve) => {
                            canvas.toBlob((blob) => {
                                blobs.push(blob);
                                log(5, `Blob ${i + 1}: ${(blob.size / 1024).toFixed(2)} KB`);
                                resolve();
                            });
                        });
                    }
                    
                    log(5, `Created ${blobs.length} blobs`);
                } else {
                    log(5, 'toBlob not supported');
                }
                
                log(5, 'Test completed');
                setStatus(5, 'PASSED');
                
            } catch (e) {
                log(5, `Exception: ${e.message}`);
                setStatus(5, 'FAILED');
            }
            enableButton(5);
        }

        // Test 6: Canvas Pattern/Gradient Overflow
        async function testPatternOverflow() {
            setStatus(6, 'RUNNING');
            disableButton(6);
            log(6, 'Testing pattern and gradient operations...');
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 600;
                const ctx = canvas.getContext('2d');
                
                log(6, 'Creating many patterns...');
                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = 100;
                patternCanvas.height = 100;
                const patternCtx = patternCanvas.getContext('2d');
                patternCtx.fillStyle = 'red';
                patternCtx.fillRect(0, 0, 100, 100);
                
                for (let i = 0; i < 1000; i++) {
                    const pattern = ctx.createPattern(patternCanvas, 'repeat');
                    ctx.fillStyle = pattern;
                    ctx.fillRect(0, 0, 800, 600);
                    
                    if (i % 100 === 0) {
                        log(6, `Created ${i + 1} patterns...`);
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                log(6, 'Testing complex gradients...');
                for (let i = 0; i < 100; i++) {
                    const gradient = ctx.createLinearGradient(0, 0, 800, 600);
                    
                    // Add many color stops
                    for (let j = 0; j < 100; j++) {
                        gradient.addColorStop(j / 100, `rgb(${j * 2}, ${j}, ${255 - j * 2})`);
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 800, 600);
                    
                    if (i % 10 === 0) {
                        log(6, `Created gradient ${i + 1}...`);
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                log(6, 'Testing radial gradients with extreme values...');
                try {
                    const rg1 = ctx.createRadialGradient(0, 0, 0, 0, 0, 1000000);
                    const rg2 = ctx.createRadialGradient(-1000, -1000, 1, 2000, 2000, 10000);
                    log(6, 'Extreme gradient values accepted');
                } catch (e) {
                    log(6, `Extreme values rejected: ${e.message}`);
                }
                
                log(6, 'Test completed');
                setStatus(6, 'PASSED');
                
            } catch (e) {
                log(6, `Exception: ${e.message}`);
                setStatus(6, 'FAILED');
            }
            enableButton(6);
        }

        // Test 7: Canvas Transform Matrix Bugs
        async function testTransformBugs() {
            setStatus(7, 'RUNNING');
            disableButton(7);
            log(7, 'Testing transformation matrix edge cases...');
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 600;
                const ctx = canvas.getContext('2d');
                
                log(7, 'Testing extreme scale values...');
                ctx.save();
                ctx.scale(0.0000001, 0.0000001);
                ctx.fillRect(0, 0, 100, 100);
                ctx.restore();
                
                ctx.save();
                ctx.scale(1000000, 1000000);
                ctx.fillRect(0, 0, 100, 100);
                ctx.restore();
                
                log(7, 'Testing extreme rotation...');
                for (let i = 0; i < 1000; i++) {
                    ctx.save();
                    ctx.rotate(Math.PI * 2 * i);
                    ctx.fillRect(0, 0, 10, 10);
                    ctx.restore();
                }
                
                log(7, 'Testing singular matrix...');
                try {
                    ctx.setTransform(0, 0, 0, 0, 0, 0);
                    ctx.fillRect(0, 0, 100, 100);
                    log(7, 'Singular matrix accepted');
                } catch (e) {
                    log(7, `Singular matrix rejected: ${e.message}`);
                }
                
                log(7, 'Testing transform accumulation...');
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                for (let i = 0; i < 10000; i++) {
                    ctx.translate(0.1, 0.1);
                    ctx.scale(1.001, 1.001);
                    ctx.rotate(0.001);
                }
                
                const transform = ctx.getTransform();
                log(7, `Final transform: a=${transform.a.toFixed(4)}, d=${transform.d.toFixed(4)}`);
                
                log(7, 'Test completed');
                setStatus(7, 'PASSED');
                
            } catch (e) {
                log(7, `Exception: ${e.message}`);
                setStatus(7, 'FAILED');
            }
            enableButton(7);
        }

        // Test 8: Cross-Canvas Memory Confusion
        async function testCrossCanvasConfusion() {
            setStatus(8, 'RUNNING');
            disableButton(8);
            log(8, 'Testing cross-canvas memory operations...');
            
            try {
                log(8, 'Creating multiple canvases...');
                const canvases = [];
                const contexts = [];
                
                for (let i = 0; i < 10; i++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = `rgb(${i * 25}, 0, 0)`;
                    ctx.fillRect(0, 0, 512, 512);
                    canvases.push(canvas);
                    contexts.push(ctx);
                }
                
                log(8, 'Testing cross-canvas drawImage...');
                for (let i = 0; i < contexts.length; i++) {
                    for (let j = 0; j < canvases.length; j++) {
                        if (i !== j) {
                            contexts[i].drawImage(canvases[j], 0, 0);
                        }
                    }
                    
                    if (i % 2 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                log(8, 'Testing ImageData transfer between canvases...');
                for (let i = 0; i < contexts.length - 1; i++) {
                    const imageData = contexts[i].getImageData(0, 0, 512, 512);
                    contexts[i + 1].putImageData(imageData, 0, 0);
                }
                
                log(8, 'Testing pattern sharing...');
                const patternSource = canvases[0];
                for (let i = 1; i < contexts.length; i++) {
                    const pattern = contexts[i].createPattern(patternSource, 'repeat');
                    contexts[i].fillStyle = pattern;
                    contexts[i].fillRect(0, 0, 512, 512);
                }
                
                log(8, 'Modifying source canvas while pattern active...');
                contexts[0].fillStyle = 'blue';
                contexts[0].fillRect(0, 0, 512, 512);
                
                for (let i = 1; i < contexts.length; i++) {
                    contexts[i].fillRect(0, 0, 512, 512);
                }
                
                log(8, 'Test completed');
                setStatus(8, 'PASSED');
                
            } catch (e) {
                log(8, `Exception: ${e.message}`);
                setStatus(8, 'FAILED');
            }
            enableButton(8);
        }
    </script>
</body>
</html>

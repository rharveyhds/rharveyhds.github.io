<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resource Exhaustion Tests</title>
    <style>
        body {
            font-family: monospace;
            background: #1a0a0a;
            color: #ff9900;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        h1 {
            color: #ff6600;
            border-bottom: 2px solid #ff6600;
            padding-bottom: 10px;
        }
        .warning {
            background: #331100;
            border: 2px solid #ff6600;
            padding: 15px;
            margin: 15px 0;
            color: #ffcc00;
        }
        .test-section {
            background: #2a1a1a;
            border: 1px solid #ff9900;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        button {
            background: #ff6600;
            color: #fff;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: monospace;
            font-weight: bold;
            border-radius: 3px;
        }
        button:hover {
            background: #ff9900;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .log {
            background: #000;
            border: 1px solid #ff9900;
            padding: 10px;
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.85em;
        }
        h3 {
            color: #ffcc00;
            margin-top: 0;
        }
        .status {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 3px;
            margin-left: 10px;
            font-size: 0.85em;
        }
        .status.running {
            background: #664400;
            color: #ffcc00;
        }
        .status.passed {
            background: #006600;
            color: #00ff00;
        }
        .status.failed {
            background: #660000;
            color: #ff0000;
        }
        .metric {
            background: #222;
            padding: 10px;
            margin: 10px 0;
            border-left: 3px solid #ff6600;
        }
        .metric-value {
            color: #ffcc00;
            font-size: 1.2em;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Resource Exhaustion & DoS Test Suite</h1>
        
        <div class="warning">
            ⚠️ These tests explore various resource exhaustion vectors.
            Tests are incremental to avoid complete system hangs.
        </div>

        <div class="test-section">
            <h3>System Resources</h3>
            <div class="metric">
                <div>Memory: <span class="metric-value" id="memory">Unknown</span></div>
                <div>Cores: <span class="metric-value" id="cores">Unknown</span></div>
                <div>Connection: <span class="metric-value" id="connection">Unknown</span></div>
            </div>
        </div>

        <div class="test-section">
            <h3>Test 1: DOM Node Exhaustion <span class="status" id="status1"></span></h3>
            <p>Find maximum DOM nodes before slowdown/crash</p>
            <button onclick="testDOMExhaustion()" id="btn1">Run Test</button>
            <div class="log" id="log1"></div>
        </div>

        <div class="test-section">
            <h3>Test 2: Event Listener Leak <span class="status" id="status2"></span></h3>
            <p>Tests memory leaks from excessive event listeners</p>
            <button onclick="testEventListenerLeak()" id="btn2">Run Test</button>
            <div class="log" id="log2"></div>
        </div>

        <div class="test-section">
            <h3>Test 3: XHR/Fetch Connection Exhaustion <span class="status" id="status3"></span></h3>
            <p>Tests maximum concurrent network connections</p>
            <button onclick="testNetworkExhaustion()" id="btn3">Run Test</button>
            <div class="log" id="log3"></div>
        </div>

        <div class="test-section">
            <h3>Test 4: Timer/Interval Exhaustion <span class="status" id="status4"></span></h3>
            <p>Tests limits on setTimeout/setInterval</p>
            <button onclick="testTimerExhaustion()" id="btn4">Run Test</button>
            <div class="log" id="log4"></div>
        </div>

        <div class="test-section">
            <h3>Test 5: Nested iframe Resource Usage <span class="status" id="status5"></span></h3>
            <p>Tests resource usage from nested iframes</p>
            <button onclick="testIframeExhaustion()" id="btn5">Run Test</button>
            <div class="log" id="log5"></div>
        </div>

        <div class="test-section">
            <h3>Test 6: Web Worker Exhaustion <span class="status" id="status6"></span></h3>
            <p>Tests maximum number of Web Workers</p>
            <button onclick="testWorkerExhaustion()" id="btn6">Run Test</button>
            <div class="log" id="log6"></div>
        </div>

        <div class="test-section">
            <h3>Test 7: Video/Audio Element Exhaustion <span class="status" id="status7"></span></h3>
            <p>Tests limits on media elements</p>
            <button onclick="testMediaExhaustion()" id="btn7">Run Test</button>
            <div class="log" id="log7"></div>
        </div>

        <div class="test-section">
            <h3>Test 8: CSS Style Exhaustion <span class="status" id="status8"></span></h3>
            <p>Tests stylesheet and style rule limits</p>
            <button onclick="testCSSExhaustion()" id="btn8">Run Test</button>
            <div class="log" id="log8"></div>
        </div>

        <div class="test-section">
            <h3>Test 9: WebGL Context Exhaustion <span class="status" id="status9"></span></h3>
            <p>Tests WebGL context creation limits</p>
            <button onclick="testWebGLExhaustion()" id="btn9">Run Test</button>
            <div class="log" id="log9"></div>
        </div>

        <div class="test-section">
            <h3>Test 10: Large String Allocation <span class="status" id="status10"></span></h3>
            <p>Tests JavaScript heap limits with large strings</p>
            <button onclick="testStringExhaustion()" id="btn10">Run Test</button>
            <div class="log" id="log10"></div>
        </div>
    </div>

    <script>
        function log(testNum, message) {
            const logEl = document.getElementById('log' + testNum);
            const timestamp = new Date().toLocaleTimeString();
            logEl.textContent += `[${timestamp}] ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        function setStatus(testNum, status) {
            const statusEl = document.getElementById('status' + testNum);
            statusEl.textContent = status;
            statusEl.className = 'status ' + status.toLowerCase();
        }

        function disableButton(testNum) {
            document.getElementById('btn' + testNum).disabled = true;
        }

        function enableButton(testNum) {
            document.getElementById('btn' + testNum).disabled = false;
        }

        // Display system info
        function displaySystemInfo() {
            document.getElementById('memory').textContent = navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Unknown';
            document.getElementById('cores').textContent = navigator.hardwareConcurrency || 'Unknown';
            document.getElementById('connection').textContent = navigator.connection ? navigator.connection.effectiveType : (navigator.onLine ? 'Online' : 'Offline');
        }

        // Test 1: DOM Node Exhaustion
        async function testDOMExhaustion() {
            setStatus(1, 'RUNNING');
            disableButton(1);
            log(1, 'Testing DOM node limits...');
            
            try {
                const container = document.createElement('div');
                document.body.appendChild(container);
                let nodeCount = 0;
                const batchSize = 1000;
                const maxNodes = 100000;
                
                log(1, `Creating DOM nodes in batches of ${batchSize}...`);
                
                for (let batch = 0; batch < maxNodes / batchSize; batch++) {
                    for (let i = 0; i < batchSize; i++) {
                        const div = document.createElement('div');
                        div.textContent = `Node ${nodeCount++}`;
                        div.className = 'test-node';
                        container.appendChild(div);
                    }
                    
                    if (batch % 10 === 0) {
                        log(1, `Created ${nodeCount} nodes...`);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                log(1, `Successfully created ${nodeCount} DOM nodes`);
                log(1, 'Cleaning up...');
                document.body.removeChild(container);
                
                setStatus(1, 'PASSED');
                
            } catch (e) {
                log(1, `Exception: ${e.message}`);
                setStatus(1, 'FAILED');
            }
            enableButton(1);
        }

        // Test 2: Event Listener Leak
        async function testEventListenerLeak() {
            setStatus(2, 'RUNNING');
            disableButton(2);
            log(2, 'Testing event listener limits...');
            
            try {
                const elements = [];
                const listenerCount = 10000;
                
                log(2, 'Creating elements with multiple listeners...');
                
                for (let i = 0; i < 100; i++) {
                    const el = document.createElement('div');
                    elements.push(el);
                    
                    for (let j = 0; j < 100; j++) {
                        el.addEventListener('click', function handler() {});
                        el.addEventListener('mouseover', function handler() {});
                        el.addEventListener('mouseout', function handler() {});
                    }
                    
                    if (i % 10 === 0) {
                        log(2, `Created ${i} elements with ~300 listeners each...`);
                        await new Promise(resolve => setTimeout(resolve, 20));
                    }
                }
                
                log(2, `Total estimated listeners: ${elements.length * 300}`);
                log(2, 'Testing listener memory retention...');
                
                elements.length = 0;
                
                log(2, 'Test completed');
                setStatus(2, 'PASSED');
                
            } catch (e) {
                log(2, `Exception: ${e.message}`);
                setStatus(2, 'FAILED');
            }
            enableButton(2);
        }

        // Test 3: XHR/Fetch Connection Exhaustion
        async function testNetworkExhaustion() {
            setStatus(3, 'RUNNING');
            disableButton(3);
            log(3, 'Testing network connection limits...');
            
            try {
                const requests = [];
                const maxRequests = 100;
                
                log(3, `Attempting ${maxRequests} concurrent requests...`);
                
                for (let i = 0; i < maxRequests; i++) {
                    const promise = fetch('https://httpbin.org/delay/10')
                        .then(r => {
                            log(3, `Request ${i} completed`);
                            return r;
                        })
                        .catch(e => {
                            log(3, `Request ${i} failed: ${e.message}`);
                        });
                    
                    requests.push(promise);
                    
                    if (i % 10 === 0) {
                        log(3, `Initiated ${i} requests...`);
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                log(3, 'Waiting for requests to complete...');
                await Promise.allSettled(requests);
                
                log(3, 'Test completed');
                setStatus(3, 'PASSED');
                
            } catch (e) {
                log(3, `Exception: ${e.message}`);
                setStatus(3, 'FAILED');
            }
            enableButton(3);
        }

        // Test 4: Timer/Interval Exhaustion
        async function testTimerExhaustion() {
            setStatus(4, 'RUNNING');
            disableButton(4);
            log(4, 'Testing timer limits...');
            
            try {
                const timers = [];
                const timerCount = 10000;
                
                log(4, `Creating ${timerCount} timers...`);
                
                for (let i = 0; i < timerCount; i++) {
                    const timer = setTimeout(() => {}, 60000);
                    timers.push(timer);
                    
                    if (i % 1000 === 0) {
                        log(4, `Created ${i} timers...`);
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                log(4, `Successfully created ${timerCount} timers`);
                log(4, 'Clearing timers...');
                
                for (let timer of timers) {
                    clearTimeout(timer);
                }
                
                log(4, 'Testing intervals...');
                const intervals = [];
                
                for (let i = 0; i < 1000; i++) {
                    const interval = setInterval(() => {}, 1000);
                    intervals.push(interval);
                }
                
                log(4, `Created ${intervals.length} intervals`);
                
                for (let interval of intervals) {
                    clearInterval(interval);
                }
                
                log(4, 'Test completed');
                setStatus(4, 'PASSED');
                
            } catch (e) {
                log(4, `Exception: ${e.message}`);
                setStatus(4, 'FAILED');
            }
            enableButton(4);
        }

        // Test 5: Nested iframe Exhaustion
        async function testIframeExhaustion() {
            setStatus(5, 'RUNNING');
            disableButton(5);
            log(5, 'Testing iframe limits...');
            
            try {
                const iframes = [];
                const maxIframes = 50;
                
                log(5, `Creating ${maxIframes} iframes...`);
                
                for (let i = 0; i < maxIframes; i++) {
                    const iframe = document.createElement('iframe');
                    iframe.style.display = 'none';
                    iframe.src = 'about:blank';
                    document.body.appendChild(iframe);
                    iframes.push(iframe);
                    
                    if (i % 10 === 0) {
                        log(5, `Created ${i} iframes...`);
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                log(5, `Successfully created ${iframes.length} iframes`);
                log(5, 'Cleaning up...');
                
                for (let iframe of iframes) {
                    document.body.removeChild(iframe);
                }
                
                log(5, 'Test completed');
                setStatus(5, 'PASSED');
                
            } catch (e) {
                log(5, `Exception: ${e.message}`);
                setStatus(5, 'FAILED');
            }
            enableButton(5);
        }

        // Test 6: Web Worker Exhaustion
        async function testWorkerExhaustion() {
            setStatus(6, 'RUNNING');
            disableButton(6);
            log(6, 'Testing Web Worker limits...');
            
            try {
                if (typeof Worker === 'undefined') {
                    log(6, 'Web Workers not supported');
                    setStatus(6, 'PASSED');
                    enableButton(6);
                    return;
                }
                
                const workers = [];
                const workerCode = 'self.onmessage = function(e) { self.postMessage(e.data); }';
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);
                
                log(6, 'Creating Web Workers...');
                
                for (let i = 0; i < 100; i++) {
                    try {
                        const worker = new Worker(workerUrl);
                        workers.push(worker);
                        
                        if (i % 10 === 0) {
                            log(6, `Created ${i} workers...`);
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                    } catch (e) {
                        log(6, `Failed at worker ${i}: ${e.message}`);
                        break;
                    }
                }
                
                log(6, `Successfully created ${workers.length} workers`);
                log(6, 'Terminating workers...');
                
                for (let worker of workers) {
                    worker.terminate();
                }
                
                URL.revokeObjectURL(workerUrl);
                
                log(6, 'Test completed');
                setStatus(6, 'PASSED');
                
            } catch (e) {
                log(6, `Exception: ${e.message}`);
                setStatus(6, 'FAILED');
            }
            enableButton(6);
        }

        // Test 7: Video/Audio Element Exhaustion
        async function testMediaExhaustion() {
            setStatus(7, 'RUNNING');
            disableButton(7);
            log(7, 'Testing media element limits...');
            
            try {
                const mediaElements = [];
                const maxMedia = 100;
                const audioData = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=';
                
                log(7, `Creating ${maxMedia} audio elements...`);
                
                for (let i = 0; i < maxMedia; i++) {
                    const audio = document.createElement('audio');
                    audio.src = audioData;
                    mediaElements.push(audio);
                    
                    if (i % 10 === 0) {
                        log(7, `Created ${i} audio elements...`);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                log(7, `Successfully created ${mediaElements.length} audio elements`);
                log(7, 'Attempting to load all media...');
                
                for (let i = 0; i < mediaElements.length; i++) {
                    try {
                        mediaElements[i].load();
                    } catch (e) {
                        log(7, `Load failed at ${i}: ${e.message}`);
                    }
                    
                    if (i % 20 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                log(7, 'Test completed');
                setStatus(7, 'PASSED');
                
            } catch (e) {
                log(7, `Exception: ${e.message}`);
                setStatus(7, 'FAILED');
            }
            enableButton(7);
        }

        // Test 8: CSS Style Exhaustion
        async function testCSSExhaustion() {
            setStatus(8, 'RUNNING');
            disableButton(8);
            log(8, 'Testing CSS limits...');
            
            try {
                const style = document.createElement('style');
                document.head.appendChild(style);
                const sheet = style.sheet;
                
                log(8, 'Creating CSS rules...');
                
                for (let i = 0; i < 10000; i++) {
                    try {
                        sheet.insertRule(`.class${i} { color: rgb(${i % 255}, ${(i * 2) % 255}, ${(i * 3) % 255}); }`, sheet.cssRules.length);
                    } catch (e) {
                        log(8, `Rule insertion failed at ${i}: ${e.message}`);
                        break;
                    }
                    
                    if (i % 1000 === 0) {
                        log(8, `Created ${i} CSS rules...`);
                        await new Promise(resolve => setTimeout(resolve, 20));
                    }
                }
                
                log(8, `Total CSS rules: ${sheet.cssRules.length}`);
                document.head.removeChild(style);
                
                log(8, 'Test completed');
                setStatus(8, 'PASSED');
                
            } catch (e) {
                log(8, `Exception: ${e.message}`);
                setStatus(8, 'FAILED');
            }
            enableButton(8);
        }

        // Test 9: WebGL Context Exhaustion
        async function testWebGLExhaustion() {
            setStatus(9, 'RUNNING');
            disableButton(9);
            log(9, 'Testing WebGL context limits...');
            
            try {
                const canvases = [];
                const contexts = [];
                
                log(9, 'Creating WebGL contexts...');
                
                for (let i = 0; i < 50; i++) {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = 256;
                        canvas.height = 256;
                        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                        
                        if (!gl) {
                            log(9, `WebGL context creation failed at ${i}`);
                            break;
                        }
                        
                        gl.clearColor(Math.random(), Math.random(), Math.random(), 1.0);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        
                        canvases.push(canvas);
                        contexts.push(gl);
                        
                        if (i % 5 === 0) {
                            log(9, `Created ${i} WebGL contexts...`);
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                    } catch (e) {
                        log(9, `Exception at context ${i}: ${e.message}`);
                        break;
                    }
                }
                
                log(9, `Successfully created ${contexts.length} WebGL contexts`);
                
                if (contexts.length > 0 && contexts[0].getExtension) {
                    const ext = contexts[0].getExtension('WEBGL_lose_context');
                    if (ext) {
                        log(9, 'WEBGL_lose_context extension available');
                        for (let ctx of contexts) {
                            const loseExt = ctx.getExtension('WEBGL_lose_context');
                            if (loseExt) loseExt.loseContext();
                        }
                    }
                }
                
                log(9, 'Test completed');
                setStatus(9, 'PASSED');
                
            } catch (e) {
                log(9, `Exception: ${e.message}`);
                setStatus(9, 'FAILED');
            }
            enableButton(9);
        }

        // Test 10: Large String Allocation
        async function testStringExhaustion() {
            setStatus(10, 'RUNNING');
            disableButton(10);
            log(10, 'Testing JavaScript heap limits...');
            
            try {
                const strings = [];
                const chunkSize = 10 * 1024 * 1024; // 10MB
                
                log(10, `Allocating strings in ${chunkSize / 1024 / 1024}MB chunks...`);
                
                for (let i = 0; i < 100; i++) {
                    try {
                        const str = 'A'.repeat(chunkSize);
                        strings.push(str);
                        log(10, `Allocated ${(i + 1) * chunkSize / 1024 / 1024}MB...`);
                        
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (e) {
                        log(10, `Allocation failed at ${i * chunkSize / 1024 / 1024}MB: ${e.message}`);
                        break;
                    }
                }
                
                log(10, `Total allocated: ${strings.length * chunkSize / 1024 / 1024}MB`);
                log(10, 'Clearing strings...');
                strings.length = 0;
                
                log(10, 'Test completed');
                setStatus(10, 'PASSED');
                
            } catch (e) {
                log(10, `Exception: ${e.message}`);
                setStatus(10, 'FAILED');
            }
            enableButton(10);
        }

        // Initialize
        displaySystemInfo();
    </script>
</body>
</html>
